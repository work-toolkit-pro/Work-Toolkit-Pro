<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Work Toolkit </title> <script src="https://cdn.tailwindcss.com"></script>
<script>tailwind.config = { darkMode: 'media' }</script>
<script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script defer="" src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
<script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
<!-- Tesseract.js for OCR -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<!-- PDF.js for reading PDFs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<!-- pdf.js for rendering -->
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script>
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
</script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script defer="" src="https://cdn.jsdelivr.net/npm/mammoth@1.4.1/mammoth.browser.min.js"></script>
<script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" rel="stylesheet"/>
<style>
  :root { --card: #ffffff; --bg: #f1f5f9; --muted: #64748b; }
  @media (prefers-color-scheme: dark) {
    :root { --card: #0f1724; --bg: #071029; --muted: #94a3b8; }
  }
  html { scroll-behavior: smooth; }
  /* make file inputs look consistent on small screens */
  input[type=file] { accent-color: #2563eb; }

  .suggestion {
    color: #ef4444; /* red-500 */
    text-decoration: underline;
  }
  .correction {
    color: #22c55e; /* green-500 */
    font-weight: bold;
  }

  .cropper-container {
    max-width: 100%;
  }

  #cropperImg {
    max-width: 100%;
  }

  /* --- Mobile tweaks for header select --- */
  @media (max-width: 640px){
    #mobileMenu{ font-size:14px; height:36px; padding:.35rem .5rem; max-width:52vw; }
    header .max-w-6xl{ padding-left:12px; padding-right:12px; }
  }

</style>
<link href="/Work-Toolkit/manifest.json" rel="manifest"/> <meta content="#2563eb" name="theme-color"/></head>
<body class="bg-[color:var(--bg)] text-slate-900 dark:text-slate-100">
<header class="sticky top-0 z-30 bg-white/80 dark:bg-slate-900/80 backdrop-blur border-b border-slate-200 dark:border-slate-800">
<div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
<div class="flex items-center gap-3">
<div class="w-10 h-10 rounded-lg bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-200 grid place-items-center font-bold">WT</div>
<div>
<div class="text-lg sm:text-xl font-bold">Work Toolkit</div> <div class="text-xs text-[color:var(--muted)]">Made by Tushar</div>
</div>
</div>
<nav class="hidden md:flex items-center gap-4 text-sm"><a class="hover:text-blue-600" href="#jpg2pdf">1. JPG / PNG → PDF</a><a class="hover:text-blue-600" href="#resizer">2. Image Resizer (Indian presets included)</a><a class="hover:text-blue-600" href="#dpi">3. DPI Changer (accurate metadata)</a><a class="hover:text-blue-600" href="#compressor">4. Image Compressor</a><a class="hover:text-blue-600" href="#pdf2img">5. PDF → JPG/PNG (client-side)</a><a class="hover:text-blue-600" href="#pdfcompressor">6. PDF Compressor</a><a class="hover:text-blue-600" href="#converter">7. Image Format Converter</a><a class="hover:text-blue-600" href="#pdfmergesplit">8. PDF Merge &amp; Split</a><a class="hover:text-blue-600" href="#ocr-tool">9. OCR Tool (Image/PDF → Text)</a><a class="hover:text-blue-600" href="#csv-excel">10. CSV ↔ Excel Converter</a><a class="hover:text-blue-600" href="#qr-generator">11. QR Code Generator</a><a class="hover:text-blue-600" href="#grammar">12. Basic Grammar Checker</a><a class="hover:text-blue-600" href="#cropper">13. Image Cropper</a><a class="hover:text-blue-600" href="#filter">14. Image Filter/Effects</a></nav>
<div class="md:hidden">
<select class="rounded border bg-white/80 dark:bg-slate-800/70 text-sm h-9 px-2 max-w-[52vw]" id="mobileMenu" onchange="if(this.value) location.hash=this.value">
<option value="">Menu</option>
<option value="#jpg2pdf">1. JPG / PNG → PDF</option><option value="#resizer">2. Image Resizer (Indian presets included)</option><option value="#dpi">3. DPI Changer (accurate metadata)</option><option value="#compressor">4. Image Compressor</option><option value="#pdf2img">5. PDF → JPG/PNG (client-side)</option><option value="#pdfcompressor">6. PDF Compressor</option><option value="#converter">7. Image Format Converter</option><option value="#pdfmergesplit">8. PDF Merge &amp; Split</option><option value="#ocr-tool">9. OCR Tool (Image/PDF → Text)</option><option value="#csv-excel">10. CSV ↔ Excel Converter</option><option value="#qr-generator">11. QR Code Generator</option><option value="#grammar">12. Basic Grammar Checker</option><option value="#cropper">13. Image Cropper</option><option value="#filter">14. Image Filter/Effects</option></select>
</div>
</div>
</header>
<main class="max-w-6xl mx-auto px-4 py-8 space-y-8">
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow">
<h1 class="text-2xl font-bold">Your Go-To Hub for Everyday Utilities!</h1>
<p class="mt-2 text-sm text-[color:var(--muted)]"><strong></strong></p> <p class="mt-2 text-sm text-[color:var(--muted)]">Welcome to Work Toolkit a collection of handy online tools designed to simplify your daily office tasks, from quick form fill-ups to essential data manipulation and image processing. We've got you covered.
 No ads like other websites🙂</p>
</section>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="jpg2pdf">
<h2 class="text-lg font-semibold">1. JPG / PNG → PDF</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">Select multiple images; order becomes PDF pages.</p>
<input accept="image/jpeg,image/png" class="mt-3 w-full" id="jpgPdfFiles" multiple="" type="file"/>
<div class="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-2">
<button class="col-span-1 sm:col-span-2 rounded bg-blue-600 hover:bg-blue-700 text-white py-2" id="jpgPdfBtn">Convert &amp; Download PDF</button>
<div class="text-sm text-[color:var(--muted)] p-2" id="jpgPdfInfo"></div>
</div>
</section>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="resizer">
<h2 class="text-lg font-semibold">2. Image Resizer (Indian presets included)</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">Resize by pixels or by physical units (cm / in / mm) with DPI.</p>
<div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-4">
<div>
<label class="block text-sm">Choose image</label>
<input accept="image/*" class="mt-1 w-full" id="resizeFile" type="file"/>
<label class="block text-sm mt-3">Preset (300 DPI)</label>
<select class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="preset">
<option value="">— select —</option>
<option value="413x531">Passport 35×45 mm → 413×531 px</option>
<option value="600x600">Passport 50×50 mm (2×2 in) → 600×600 px</option>
<option value="295x413">PAN 25×35 mm → 295×413 px</option>
<option value="350x350">Aadhaar 35×35 mm → 350×350 px</option>
<option value="300x300">Driving license 25×25 mm → 300×300 px</option>
</select>
</div>
<div>
<label class="block text-sm">Width</label>
<input class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="resizeW" placeholder="width" type="number"/>
<label class="block text-sm mt-2">Height</label>
<input class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="resizeH" placeholder="height" type="number"/>
<div class="mt-2 grid grid-cols-3 gap-2">
<select class="rounded border px-2 py-1 bg-white dark:bg-slate-800" id="resizeUnit">
<option value="px">px</option>
<option value="cm">cm</option>
<option value="in">in</option>
<option value="mm">mm</option>
</select>
<input class="rounded border px-2 py-1 bg-white dark:bg-slate-800" id="resizeDpi" type="number" value="300"/>
<button class="rounded bg-blue-600 hover:bg-blue-700 text-white py-1" id="resizeBtn">Resize &amp; Download</button>
</div>
</div>
</div>
<p class="mt-3 text-sm text-[color:var(--muted)]" id="resizeResult"></p>
<canvas class="hidden" id="resizeCanvas"></canvas>
</section>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="dpi">
<h2 class="text-lg font-semibold">3. DPI Changer (accurate metadata)</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">Writes DPI into JPEG (JFIF + EXIF) and PNG (pHYs). Choose to keep pixel dimensions (metadata-only) or resample to keep physical print size.</p>
<div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
<div>
<label class="block text-sm">Image (JPEG or PNG)</label>
<input accept="image/jpeg,image/png" class="mt-1 w-full" id="dpiFile" type="file"/>
</div>
<div>
<label class="block text-sm">Target DPI</label>
<input class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="dpiValue" type="number" value="300"/>
<label class="block text-sm mt-2">Mode</label>
<select class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="dpiMode">
<option value="keep">Keep pixels (change metadata only)</option>
<option value="resample">Resample (change pixel size to keep physical size)</option>
</select>
</div>
</div>
<div class="mt-3 flex gap-2">
<button class="rounded bg-blue-600 hover:bg-blue-700 text-white py-2 px-4" id="dpiBtn">Apply DPI &amp; Download</button>
<div class="text-sm text-[color:var(--muted)] self-center" id="dpiInfo"></div>
</div>
<canvas class="hidden" id="dpiCanvas"></canvas>
</section>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="compressor">
<h2 class="text-lg font-semibold">4. Image Compressor</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">Compress with quality slider or attempt to reach a target size (iterative).</p>
<div class="grid grid-cols-1 md:grid-cols-2 gap-3 mt-3">
<div>
<label class="block text-sm">Choose image</label>
<input accept="image/*" class="mt-1 w-full" id="cmpFile" type="file"/>
</div>
<div>
<label class="block text-sm">Quality (1–100)</label>
<input class="mt-1 w-full" id="cmpQuality" max="100" min="1" type="range" value="80"/>
<div class="flex items-center justify-between text-xs text-[color:var(--muted)]"><span>1</span><span id="cmpQLabel">80</span><span>100</span></div>
<label class="block text-sm mt-2">Target size (KB) — optional</label>
<input class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="cmpTargetKB" placeholder="e.g., 200" type="number"/>
</div>
</div>
<div class="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-2">
<select class="rounded border px-2 py-1 bg-white dark:bg-slate-800" id="cmpFormat">
<option value="auto">Auto</option>
<option value="image/jpeg">JPEG</option>
<option value="image/webp">WebP</option>
</select>
<button class="rounded bg-blue-600 hover:bg-blue-700 text-white py-2" id="cmpBtn">Compress &amp; Download</button>
<div class="text-sm text-[color:var(--muted)] self-center" id="cmpInfo"></div>
<div class="col-span-1 sm:col-span-3 mt-2" id="cmpProgress">
<div class="w-full bg-slate-200 dark:bg-slate-700 h-2 rounded overflow-hidden hidden" id="cmpProgBarWrap">
<div class="h-2 bg-blue-600" id="cmpProgBar" style="width:0%"></div>
</div>
<div class="text-xs text-[color:var(--muted)] mt-1 hidden" id="cmpProgText">0%</div>
</div></div><label class="inline-flex items-center gap-2 mt-1"><input id="cmpDocMode" type="checkbox"/><span>Document mode (text/scans: sharper, smaller)</span></label>
<canvas class="hidden" id="cmpCanvas"></canvas>
</section>
<!-- 5. PDF → JPG/PNG (client-side) -->
<section class="mt-6 bg-white dark:bg-slate-800 rounded-2xl shadow border border-slate-200 dark:border-slate-700 p-4 md:p-6" id="pdf2img">
<h2 class="text-xl font-bold text-slate-900 dark:text-white mb-1">5. PDF → JPG/PNG (client-side)</h2>
<p class="text-slate-500 dark:text-slate-400 mb-4">
    Convert each page of a PDF into images. Multiple pages are downloaded as a ZIP.
  </p>
<div class="grid grid-cols-1 md:grid-cols-6 gap-3 items-end">
<!-- PDF file -->
<div class="md:col-span-2">
<label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Choose PDF</label>
<input accept="application/pdf" class="w-full block rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-900 px-3 py-2 text-sm" id="pdf2imgFile" type="file"/>
</div>
<!-- format -->
<div>
<label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Choose PDF Format</label>
<select class="w-full rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-900 px-3 py-2 text-sm" id="pdf2imgFormat">
<option selected="" value="image/png">PNG (sharper)</option>
<option value="image/jpeg">JPG</option>
</select>
</div>
<!-- jpg quality (only visible for jpg) -->
<div id="pdf2imgQWrap">
<label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">JPG Quality</label>
<input class="w-full rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-900 px-3 py-2 text-sm" id="pdf2imgQuality" max="100" min="10" step="1" type="number" value="92"/>
</div>
<!-- scale -->
<div>
<label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Scale</label>
<select class="w-full rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-900 px-3 py-2 text-sm" id="pdf2imgScale">
<option value="1">100%</option>
<option value="1.25">125%</option>
<option selected="" value="1.5">150%</option>
<option value="2">200%</option>
</select>
</div>
<!-- pages -->
<div>
<label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Pages (e.g., 1‑3,5)</label>
<input class="w-full rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-900 px-3 py-2 text-sm" id="pdf2imgRange" placeholder="All" type="text"/>
</div>
<!-- background -->
<div>
<label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Background</label>
<select class="w-full rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-900 px-3 py-2 text-sm" id="pdf2imgBg">
<option selected="" value="white">White</option>
<option value="transparent">Transparent (PNG only)</option>
</select>
</div>
</div>
<!-- actions -->
<div class="mt-4 flex flex-wrap gap-3">
<button class="inline-flex items-center justify-center rounded-lg bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 text-sm font-medium" id="pdf2imgStart">
      Convert &amp; Download
    </button>
<button class="inline-flex items-center justify-center rounded-lg border border-slate-300 dark:border-slate-600 px-4 py-2 text-sm font-medium text-slate-700 dark:text-slate-300" id="pdf2imgCancel">
      Cancel
    </button>
</div>
<!-- progress -->
<div class="mt-3 h-2 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden hidden" id="pdf2imgProgress">
<div class="h-full w-0 bg-blue-600" id="pdf2imgProgressBar"></div>
</div>
<div class="mt-2 text-sm text-slate-500 dark:text-slate-400" id="pdf2imgInfo"></div>
</section>
<script>
(function(){
  const $ = id => document.getElementById(id);

  // Elements
  const fileIn = $('pdf2imgFile');
  const fmtSel = $('pdf2imgFormat');
  const qWrap  = $('pdf2imgQWrap');
  const qInput = $('pdf2imgQuality');
  const scaleSel = $('pdf2imgScale');
  const rangeIn = $('pdf2imgRange');
  const bgSel   = $('pdf2imgBg');
  const startBtn= $('pdf2imgStart');
  const cancelBtn=$('pdf2imgCancel');
  const prog    = $('pdf2imgProgress');
  const bar     = $('pdf2imgProgressBar');
  const info    = $('pdf2imgInfo');

  if (!fileIn || !fmtSel || !qWrap || !qInput || !scaleSel || !rangeIn || !bgSel || !startBtn || !cancelBtn || !prog || !bar || !info) {
    console.warn('PDF→Image tool: missing DOM nodes — check IDs in the section markup.');
    return;
  }

  // JPG quality only when JPG selected
  function syncQualityVis(){
    qWrap.style.display = fmtSel.value.includes('jpeg') ? 'inline-block' : 'none';
  }
  fmtSel.addEventListener('change', syncQualityVis);
  syncQualityVis();

  // Parse "1-3,5" ranges
  function parseRanges(txt, numPages){
    if(!txt || !txt.trim()) return Array.from({length:numPages}, (_,i)=>i+1);
    const out = new Set();
    txt.split(',').map(s=>s.trim()).forEach(part=>{
      const m = part.match(/^([0-9]+)(?:-([0-9]+))?$/);
      if(!m) return;
      let a = parseInt(m[1],10), b = m[2]?parseInt(m[2],10):a;
      if (isNaN(a)||isNaN(b)) return;
      if (a>b) [a,b]=[b,a];
      a = Math.max(1, Math.min(a, numPages));
      b = Math.max(1, Math.min(b, numPages));
      for(let p=a;p<=b;p++) out.add(p);
    });
    return [...out].sort((x,y)=>x-y);
  }

  let cancelFlag = false;
  function showProg(pct, text){
    prog.style.display = 'block';
    bar.style.width = Math.max(0, Math.min(100, pct)) + '%';
    info.textContent = text || '';
  }
  function hideProg(){ prog.style.display = 'none'; }

  async function renderPdfToImages(file, opts){
    const arrayBuf = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuf }).promise;
    const numPages = pdf.numPages;

    const pages = parseRanges(opts.range, numPages);
    if (!pages.length) throw new Error('No pages selected');

    const zip = pages.length > 1 ? new JSZip() : null;
    const results = [];
    cancelFlag = false;
    showProg(0, `Rendering 0/${pages.length}…`);

    for (let i = 0; i < pages.length; i++){
      if (cancelFlag) { info.textContent = 'Canceled.'; break; }

      const pageNo = pages[i];
      const page = await pdf.getPage(pageNo);
      const viewport = page.getViewport({ scale: Number(opts.scale) || 1 });

      // Canvas
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently:false });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      // Background
      const isJpg = opts.mime.includes('jpeg');
      if (isJpg || opts.bg === 'white') {
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
      } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
      }

      // Render page
      await page.render({ canvasContext: ctx, viewport }).promise;

      // Export
      const quality = Math.max(10, Math.min(100, Number(opts.quality) || 92)) / 100;
      const blob = await new Promise(r => canvas.toBlob(r, opts.mime, quality));
      const base = file.name.replace(/\.pdf$/i,'') || 'page';
      const fname = (pages.length>1 ? `${base}_p${pageNo}` : base) + (isJpg ? '.jpg' : '.png');

      if (zip) {
        const buf = await blob.arrayBuffer();
        zip.file(fname, buf);
      } else {
        results.push({ blob, name: fname });
      }

      const pct = Math.round(((i+1)/pages.length)*100);
      showProg(pct, `Rendered ${i+1}/${pages.length} (${pct}%)`);
    }

    if (zip && !cancelFlag) {
      info.textContent = 'Zipping…';
      const zipBlob = await zip.generateAsync({ type:'blob' });
      return [{ blob: zipBlob, name: (file.name.replace(/\.pdf$/i,'') || 'pages') + '_images.zip' }];
    }
    return results;
  }

  startBtn.addEventListener('click', async (e)=>{
    e.preventDefault(); e.stopPropagation();
    try{
      const file = fileIn.files && fileIn.files[0];
      if (!file) return alert('Choose a PDF first.');

      showProg(0, 'Starting…');
      const outputs = await renderPdfToImages(file, {
        mime: fmtSel.value || 'image/png',
        quality: qInput.value || 92,
        scale: scaleSel.value || 1,
        range: rangeIn.value || '',
        bg: bgSel.value || 'white'
      });

      if (!outputs || outputs.length === 0) { hideProg(); info.textContent='Nothing to download.'; return; }

      for (const out of outputs) {
        if (typeof window.initiateDownload === 'function') {
          window.initiateDownload(out.blob, out.name);
        } else {
          const url = URL.createObjectURL(out.blob);
          const a = document.createElement('a'); a.href = url; a.download = out.name;
          document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        }
      }
      showProg(100, cancelFlag ? 'Canceled.' : 'Done.');
      setTimeout(hideProg, 600);
    }catch(err){
      console.error(err);
      hideProg();
      info.textContent = 'Error: ' + (err && err.message || err);
    }
  });

  cancelBtn.addEventListener('click', ()=>{ cancelFlag = true; info.textContent='Canceled.'; });
})();
</script>
<!-- =========================
     PDF COMPRESSOR (NEW TOOL)
     ========================= -->
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="pdfcompressor">
<h2 class="text-lg font-semibold">6. PDF Compressor</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">
    Upload a PDF and compress it to a target size (KB or MB).
  </p>
<div class="mt-3">
<label class="block text-sm">Choose PDF</label>
<input accept="application/pdf" class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="pdfInput" type="file"/>
</div>
<div class="mt-3 grid grid-cols-2 gap-2">
<input class="rounded border px-2 py-1 bg-white dark:bg-slate-800" id="targetSize" min="1" placeholder="Target size" step="1" type="number"/>
<select class="rounded border px-2 py-1 bg-white dark:bg-slate-800" id="sizeUnit">
<option value="KB">KB</option>
<option value="MB">MB</option>
</select>
</div>
<div class="mt-3">
<button class="rounded bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 w-full" id="compressPdfBtn">
      Compress PDF
    </button>
</div>
<div class="mt-4 p-3 rounded bg-slate-100 dark:bg-slate-700 text-[color:var(--muted)]" id="pdfOutput">
    Select a PDF and set a target size to begin.
  </div>
</section>
<script>
/* Requires:
   - pdf.js (window.pdfjsLib)
   - jsPDF (window.jspdf.jsPDF)
   Your page already includes them. We set pdf.js worker here just in case.
*/
document.addEventListener("DOMContentLoaded", () => {
  if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";
  }

  const btn = document.getElementById("compressPdfBtn");
  const input = document.getElementById("pdfInput");
  const out = document.getElementById("pdfOutput");

  btn.addEventListener("click", async () => {
    try {
      if (!input.files || !input.files.length) {
        out.textContent = "⚠️ Please select a PDF file.";
        return;
      }
      const file = input.files[0];
      if (file.type !== "application/pdf") {
        out.textContent = "⚠️ Invalid file type. Please choose a PDF.";
        return;
      }

      const targetValue = parseFloat(document.getElementById("targetSize").value);
      const unit = document.getElementById("sizeUnit").value;
      if (!targetValue || targetValue <= 0) {
        out.textContent = "⚠️ Please enter a valid target size.";
        return;
      }
      const targetBytes = unit === "MB"
        ? targetValue * 1024 * 1024
        : targetValue * 1024;

      out.textContent = "Working… this may take a moment.";

      // Read PDF into memory
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(buf) }).promise;

      // Try multiple quality/scale combos until <= target
      const qualitySteps = [0.7, 0.6, 0.5, 0.45, 0.4, 0.35, 0.3];
      const scaleSteps   = [1.2, 1.0, 0.85, 0.75, 0.65]; // render scale to shrink images

      let bestBlob = null;

      for (let q of qualitySteps) {
        for (let s of scaleSteps) {
          const blob = await buildCompressedPdf(pdf, q, s);
          bestBlob = (!bestBlob || blob.size < bestBlob.size) ? blob : bestBlob;
          if (blob.size <= targetBytes) {
            bestBlob = blob;
            q = -1; // break outer
            break;
          }
        }
        if (q === -1) break;
      }

      if (!bestBlob) {
        out.textContent = "❌ Failed to compress. (Unexpected error)";
        return;
      }

      // Show result & download link
      const sizeKB = (bestBlob.size / 1024).toFixed(1);
      const achieved = `${sizeKB} KB`;
      out.innerHTML = "";

      const info = document.createElement("div");
      info.textContent = `Compressed size: ${achieved}`;
      out.appendChild(info);

      const a = document.createElement("a");
      a.href = URL.createObjectURL(bestBlob);
      a.download = "compressed.pdf";
      a.textContent = "⬇️ Download Compressed PDF";
      a.className = "inline-block mt-2 underline";
      out.appendChild(a);
    } catch (err) {
      console.error(err);
      out.textContent = "❌ Error compressing PDF. Check console for details.";
    }
  });

  async function buildCompressedPdf(pdf, quality, scale) {
    const { jsPDF } = window.jspdf;
    let doc = null;

    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const viewport = page.getViewport({ scale: scale });

      // Render page to canvas
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: false });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      // To JPEG data URL with given quality
      const imgData = canvas.toDataURL("image/jpeg", quality);

      // Use page-sized PDF pages in points (1 pt = 1/72 in).
      // We set jsPDF unit to 'pt' and match page size to the canvas.
      const w = canvas.width;
      const h = canvas.height;

      if (!doc) {
        doc = new jsPDF({ unit: "pt", format: [w, h] });
      } else {
        doc.addPage([w, h]);
      }
      doc.addImage(imgData, "JPEG", 0, 0, w, h);
    }

    return doc.output("blob");
  }
});
</script>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="converter">
<h2 class="text-lg font-semibold">7. Image Format Converter</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">Convert image files between different formats (e.g., PNG, JPEG, WebP).</p>
<div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-4">
<div>
<label class="block text-sm">Choose image</label>
<input accept="image/*" class="mt-1 w-full" id="convertFile" type="file"/>
</div>
<div>
<label class="block text-sm">Output Format</label>
<select class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="convertFormat">
<option value="image/jpeg">JPEG</option>
<option value="image/png">PNG</option>
<option value="image/webp">WebP</option>
</select>
<button class="mt-3 rounded bg-blue-600 hover:bg-blue-700 text-white py-2 w-full" id="convertBtn">Convert &amp; Download</button>
</div>
</div>
<p class="mt-3 text-sm text-[color:var(--muted)]" id="convertInfo"></p>
<canvas class="hidden" id="convertCanvas"></canvas>
</section>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="pdfmergesplit">
<h2 class="text-lg font-semibold">8. PDF Merge &amp; Split</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">
    Merge multiple PDFs into one, or split pages from a PDF.
  </p>
<!-- Merge PDF -->
<div class="mt-4">
<h3 class="text-sm font-semibold mb-1">Merge PDFs</h3>
<input accept="application/pdf" class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="mergeInput" multiple="" type="file"/>
<button class="mt-2 rounded bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 w-full" id="mergeBtn">
      Merge PDFs
    </button>
</div>
<!-- Split PDF -->
<div class="mt-6">
<h3 class="text-sm font-semibold mb-1">Split PDF</h3>
<input accept="application/pdf" class="mt-1 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="splitInput" type="file"/>
<input class="mt-2 w-full rounded border px-2 py-1 bg-white dark:bg-slate-800" id="splitRange" placeholder="Pages (e.g., 1-3,5)" type="text"/>
<button class="mt-2 rounded bg-green-600 hover:bg-green-700 text-white py-2 px-4 w-full" id="splitBtn">
      Split PDF
    </button>
</div>
<div class="mt-4 p-3 rounded bg-slate-100 dark:bg-slate-700 text-[color:var(--muted)]" id="pdfMergeSplitOutput">
    Output will appear here.
  </div>
</section>
<!-- pdf-lib -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
<script>
const outputDiv = document.getElementById("pdfMergeSplitOutput");

/* ========= Merge PDFs ========= */
document.getElementById("mergeBtn").addEventListener("click", async () => {
  const files = document.getElementById("mergeInput").files;
  if (!files.length) {
    outputDiv.textContent = "⚠️ Please select PDF files to merge.";
    return;
  }

  try {
    const { PDFDocument } = PDFLib;
    const mergedPdf = await PDFDocument.create();

    for (let file of files) {
      const bytes = await file.arrayBuffer();
      const pdf = await PDFDocument.load(bytes);
      const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
      copiedPages.forEach(p => mergedPdf.addPage(p));
    }

    const mergedBytes = await mergedPdf.save();
    const blob = new Blob([mergedBytes], { type: "application/pdf" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "merged.pdf";
    a.textContent = "⬇️ Download Merged PDF";
    outputDiv.innerHTML = "";
    outputDiv.appendChild(a);
  } catch (err) {
    console.error(err);
    outputDiv.textContent = "❌ Error merging PDFs.";
  }
});

/* ========= Split PDF ========= */
document.getElementById("splitBtn").addEventListener("click", async () => {
  const file = document.getElementById("splitInput").files[0];
  const rangeStr = document.getElementById("splitRange").value.trim();

  if (!file) {
    outputDiv.textContent = "⚠️ Please select a PDF to split.";
    return;
  }

  if (!rangeStr) {
    outputDiv.textContent = "⚠️ Please enter page numbers/ranges.";
    return;
  }

  try {
    const { PDFDocument } = PDFLib;
    const bytes = await file.arrayBuffer();
    const pdf = await PDFDocument.load(bytes);

    // Parse range input like "1-3,5"
    const ranges = rangeStr.split(",").map(r => r.trim());
    let pageNumbers = [];
    for (let r of ranges) {
      if (r.includes("-")) {
        let [start, end] = r.split("-").map(n => parseInt(n, 10));
        for (let i = start; i <= end; i++) pageNumbers.push(i - 1);
      } else {
        pageNumbers.push(parseInt(r, 10) - 1);
      }
    }

    const newPdf = await PDFDocument.create();
    const copied = await newPdf.copyPages(pdf, pageNumbers);
    copied.forEach(p => newPdf.addPage(p));

    const newBytes = await newPdf.save();
    const blob = new Blob([newBytes], { type: "application/pdf" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "split.pdf";
    a.textContent = "⬇️ Download Split PDF";
    outputDiv.innerHTML = "";
    outputDiv.appendChild(a);
  } catch (err) {
    console.error(err);
    outputDiv.textContent = "❌ Error splitting PDF.";
  }
});
</script>
<section class="mb-6 bg-[color:var(--card)] rounded-2xl p-5 shadow border border-slate-200 dark:border-slate-700" id="ocr-tool">
<h2 class="text-xl font-semibold mb-2 text-gray-900 dark:text-gray-100">9. OCR Tool (Image/PDF → Text)</h2>
<p class="text-gray-600 dark:text-gray-300 mb-4">
    Extract text from Images (JPG/PNG) or PDFs. Supports English &amp; Hindi.
  </p>
<!-- File input -->
<input accept="image/*,.pdf" class="mb-3" id="ocrFile" type="file"/>
<!-- Language selector -->
<select class="border p-2 rounded mb-3 bg-white dark:bg-slate-900 dark:text-slate-100" id="ocrLang">
<option value="eng">English</option>
<option value="hin">Hindi</option>
</select>
<!-- Button -->
<button class="bg-blue-600 text-white px-4 py-2 rounded" id="ocrBtn">Extract Text</button>
<!-- Output -->
<h3 class="mt-4 font-medium text-gray-900 dark:text-gray-100">Output:</h3>
<textarea class="w-full h-40 p-2 border rounded bg-white dark:bg-slate-900 dark:text-slate-100" id="ocrOutput"></textarea>
<!-- Copy & Download -->
<div class="mt-2 flex gap-2">
<button class="bg-green-600 text-white px-3 py-1 rounded" id="copyText">Copy</button>
<button class="bg-gray-600 text-white px-3 py-1 rounded" id="downloadText">Download .txt</button>
</div>
</section>
<script>
async function extractFromImage(file, lang) {
  const { data: { text } } = await Tesseract.recognize(file, lang);
  return text.trim();
}

async function extractFromPDF(file, lang) {
  const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
  let finalText = "";

  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
    const page = await pdf.getPage(pageNum);
    const viewport = page.getViewport({ scale: 2 });

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = viewport.width;
    canvas.height = viewport.height;

    await page.render({ canvasContext: ctx, viewport }).promise;

    const { data: { text } } = await Tesseract.recognize(canvas, lang);
    finalText += `\n--- Page ${pageNum} ---\n` + text.trim();
  }

  return finalText;
}

document.getElementById("ocrBtn").addEventListener("click", async () => {
  const file = document.getElementById("ocrFile").files[0];
  const lang = document.getElementById("ocrLang").value;
  const output = document.getElementById("ocrOutput");

  if (!file) {
    alert("Please select a file first.");
    return;
  }

  output.value = "⏳ Processing... please wait.";

  try {
    let text = "";
    if (file.type === "application/pdf") {
      text = await extractFromPDF(file, lang);
    } else {
      text = await extractFromImage(file, lang);
    }
    output.value = text || "⚠️ No text detected.";
  } catch (err) {
    output.value = "❌ Error: " + err.message;
  }
});

// Copy text
document.getElementById("copyText").addEventListener("click", () => {
  const output = document.getElementById("ocrOutput");
  output.select();
  document.execCommand("copy");
  alert("Text copied to clipboard!");
});

// Download text
document.getElementById("downloadText").addEventListener("click", () => {
  const text = document.getElementById("ocrOutput").value;
  const blob = new Blob([text], { type: "text/plain" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "ocr_output.txt";
  link.click();
});
</script>
<!-- 📌 CSV ↔ Excel Converter Tool -->
<section class="mb-6 bg-[color:var(--card)] rounded-2xl p-5 shadow border border-slate-200 dark:border-slate-700" id="csv-excel">
<h2 class="text-xl font-semibold mb-2 text-gray-900 dark:text-gray-100">10. CSV ↔ Excel Converter</h2>
<p class="text-gray-600 dark:text-gray-300 mb-4">
      Convert between CSV and Excel (.xlsx) files instantly. Works offline in your browser.
    </p>
<!-- File upload -->
<input accept=".csv,.xlsx" class="mb-3" id="csvExcelFile" type="file"/>
<!-- Action buttons -->
<div class="flex gap-2">
<button class="bg-blue-600 text-white px-4 py-2 rounded" id="toExcel">
        Convert to Excel
      </button>
<button class="bg-green-600 text-white px-4 py-2 rounded" id="toCSV">
        Convert to CSV
      </button>
</div>
</section>
<script>
// Convert CSV → Excel
document.getElementById("toExcel").addEventListener("click", () => {
  const file = document.getElementById("csvExcelFile").files[0];
  if (!file) return alert("Please upload a CSV file first.");

  const reader = new FileReader();
  reader.onload = function(e) {
    const csvData = e.target.result.trim(); // ✅ Ensure clean text
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.aoa_to_sheet(
      csvData.split("\n").map(row => row.split(","))
    );
    XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");

    XLSX.writeFile(workbook, "converted.xlsx"); // ✅ Force download
  };
  reader.readAsText(file);
});

// Convert Excel → CSV
document.getElementById("toCSV").addEventListener("click", () => {
  const file = document.getElementById("csvExcelFile").files[0];
  if (!file) return alert("Please upload an Excel file first.");

  const reader = new FileReader();
  reader.onload = function(e) {
    const data = new Uint8Array(e.target.result);
    const workbook = XLSX.read(data, { type: "array" });
    const sheetName = workbook.SheetNames[0];
    const csvData = XLSX.utils.sheet_to_csv(workbook.Sheets[sheetName]);

    const blob = new Blob([csvData], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "converted.csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  reader.readAsArrayBuffer(file);
});
</script>
<!-- QR Code Generator -->
<section class="mb-6 bg-[color:var(--card)] rounded-2xl p-5 shadow border border-slate-200 dark:border-slate-700" id="qr-generator">
<h2 class="text-xl font-semibold mb-2 text-gray-900 dark:text-gray-100">11. QR Code Generator</h2>
<p class="text-gray-600 dark:text-gray-300 mb-4">
    Enter any text or link (including image URLs), or upload a .txt file. Generate and download the QR as PNG.
  </p>
<!-- Text / URL input -->
<label class="block mb-1 text-sm text-gray-700 dark:text-gray-300">Text or Link</label>
<textarea class="w-full h-28 p-2 border rounded bg-white dark:bg-slate-900 dark:text-slate-100 mb-3" id="qrText" placeholder="Paste text or a URL here"></textarea>
<!-- Options -->
<div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4">
<div>
<label class="block mb-1 text-sm text-gray-700 dark:text-gray-300">Size (px)</label>
<input class="w-full p-2 border rounded bg-white dark:bg-slate-900 dark:text-slate-100" id="qrSize" max="1024" min="128" type="number" value="256"/>
</div>
<div>
<label class="block mb-1 text-sm text-gray-700 dark:text-gray-300">Foreground Color</label>
<input class="w-full h-10 p-1 border rounded bg-white dark:bg-slate-900 dark:text-slate-100" id="qrColor" type="color" value="#000000"/>
</div>
<div>
<label class="block mb-1 text-sm text-gray-700 dark:text-gray-300">Background Color</label>
<input class="w-full h-10 p-1 border rounded bg-white dark:bg-slate-900 dark:text-slate-100" id="qrBg" type="color" value="#ffffff"/>
</div>
</div>
<!-- Actions -->
<div class="flex flex-wrap gap-2 mb-4">
<button class="bg-blue-600 text-white px-4 py-2 rounded" id="qrGenerate">Generate QR</button>
<button class="bg-green-600 text-white px-4 py-2 rounded" disabled="" id="qrDownload">Download PNG</button>
<button class="bg-gray-600 text-white px-4 py-2 rounded" id="qrClear">Clear</button>
</div>
<!-- Output -->
<div class="flex items-center justify-center p-3 bg-gray-50 dark:bg-gray-700 rounded">
<div id="qrOutput"></div>
</div>
</section>
<!-- 📦 QRCode.js (reliable client-side lib) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script>
  const $ = (id) => document.getElementById(id);
  const qrText = $("qrText");
  const qrFile = $("qrTxtFile");
  const qrSize = $("qrSize");
  const qrColor = $("qrColor");
  const qrBg = $("qrBg");
  const qrOutput = $("qrOutput");
  const btnGenerate = $("qrGenerate");
  const btnDownload = $("qrDownload");
  const btnClear = $("qrClear");

  let qr;

  function generateQR(text) {
    if (!text) { 
      alert("Please enter text or upload a .txt file."); 
      return; 
    }

    qrOutput.innerHTML = ""; // clear old QR
    qr = new QRCode(qrOutput, {
      text: text,
      width: parseInt(qrSize.value) || 256,
      height: parseInt(qrSize.value) || 256,
      colorDark: qrColor.value,
      colorLight: qrBg.value,
      correctLevel: QRCode.CorrectLevel.H
    });

    btnDownload.disabled = false;
  }

  // ✅ Handle Generate button
  btnGenerate.addEventListener("click", () => {
    const text = (qrText.value || "").trim();
    generateQR(text);
  });

  // ✅ Handle TXT file upload → auto-generate QR
  qrFile.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const text = await file.text().catch(() => "");
    if (text.trim()) {
      qrText.value = text.trim();
      generateQR(text.trim()); // ✅ instantly create QR
    }
  });

  // ✅ Download QR
  btnDownload.addEventListener("click", () => {
    const img = qrOutput.querySelector("img") || qrOutput.querySelector("canvas");
    if (!img) { alert("No QR generated yet."); return; }

    const link = document.createElement("a");
    link.href = img.src;
    link.download = "qr_code.png";
    link.click();
  });

  // ✅ Clear everything
  btnClear.addEventListener("click", () => {
    qrOutput.innerHTML = "";
    qrText.value = "";
    qrFile.value = "";
    btnDownload.disabled = true;
  });
</script>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="cropper">
<h2 class="text-lg font-semibold">12. Image Cropper</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">Upload an image to crop it to a specific size or aspect ratio.</p>
<div class="mt-3">
<label class="block text-sm">Choose an image</label>
<input accept="image/*" class="w-full mt-1" id="cropperFile" type="file"/>
</div>
<div class="mt-4 hidden max-w-full" id="cropper-container">
<img alt="Image to crop" id="cropperImg" src=""/>
</div>
<div class="mt-4 hidden grid grid-cols-2 sm:grid-cols-3 gap-2" id="cropperActions">
<button class="rounded bg-blue-600 hover:bg-blue-700 text-white py-2" id="cropperBtn">Crop &amp; Download</button>
</div>
<div class="mt-3 text-sm text-[color:var(--muted)]" id="cropperInfo"></div>
</section>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow" id="filter">
<h2 class="text-lg font-semibold">13. Image Filter/Effects</h2>
<p class="text-xs text-[color:var(--muted)] mt-1">Apply various filters and effects to your images.</p>
<div class="mt-3">
<label class="block text-sm">Choose an image</label>
<input accept="image/*" class="w-full mt-1" id="filterFile" type="file"/>
</div>
<div class="mt-4 hidden" id="filter-preview-container">
<canvas class="max-w-full" id="filterCanvas"></canvas>
</div>
<div class="mt-4 hidden" id="filterControls">
<div class="grid grid-cols-2 gap-2">
<div>
<label class="text-sm block" for="brightness">Brightness</label>
<input class="w-full" id="brightness" max="200" min="0" type="range" value="100"/>
</div>
<div>
<label class="text-sm block" for="contrast">Contrast</label>
<input class="w-full" id="contrast" max="200" min="0" type="range" value="100"/>
</div>
</div>
<div class="grid grid-cols-3 sm:grid-cols-5 gap-2 mt-4">
<button class="filter-btn rounded bg-gray-600 hover:bg-gray-700 text-white py-2" data-filter="grayscale">Grayscale</button>
<button class="filter-btn rounded bg-gray-600 hover:bg-gray-700 text-white py-2" data-filter="sepia">Sepia</button>
<button class="filter-btn rounded bg-gray-600 hover:bg-gray-700 text-white py-2" data-filter="invert">Invert</button>
<button class="filter-btn rounded bg-gray-600 hover:bg-gray-700 text-white py-2" data-filter="blur">Blur</button>
<button class="rounded bg-gray-600 hover:bg-gray-700 text-white py-2" id="resetFilterBtn">Reset</button>
</div>
<button class="rounded bg-blue-600 hover:bg-blue-700 text-white py-2 w-full mt-4" id="downloadFilterBtn">Download Filtered Image</button>
</div>
<div class="mt-3 text-sm text-[color:var(--muted)]" id="filterInfo"></div>
</section>
<section class="bg-[color:var(--card)] rounded-2xl p-5 shadow">
<h2 class="text-lg font-semibold">Get in Touch</h2>
<p class="mt-2 text-sm text-[color:var(--muted)]">Have suggestions, feedback, or need support? Feel free to reach out to us!</p>
<p class="mt-2 text-sm text-[color:var(--muted)]">Email: <a class="text-blue-600 hover:underline" href="mailto:evltushar@gmail.com">evltushar@gmail.com</a></p>
</section>
</main>
<footer class="text-center py-6 text-sm text-[color:var(--muted)]">
  © 2025 Work Toolkit. All rights reserved. <p class="text-sm text-gray-400 mt-2">
    Disclaimer: This website is for informational and utility purposes. While we strive for accuracy,
    we do not guarantee the results of any tool or accept liability for its use.
    Users are solely responsible for ensuring their use of the tools complies with all applicable laws and regulations,
    including copyright and Digital Millennium Copyright Act (DMCA) guidelines. We do not endorse or support
    the unauthorized copying or distribution of copyrighted material, nor do we assume responsibility for any
    misuse of the tools or any consequences arising from such misuse.
  </p>
</footer>
<script>;(async () => {

document.addEventListener('DOMContentLoaded', function(){
  ['cmpBtn','resizeBtn','pdfcBtn','qrgBtn'].forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.setAttribute('type','button');
  });
});


/* ---------------- Helpers ---------------- */
const fileToImage = (file)=>new Promise((res,rej)=>{ const img = new Image(); img.onload=()=>res(img); img.onerror=rej; img.src = URL.createObjectURL(file); });
const canvasToBlob = (canvas, type='image/png', q=0.92)=>new Promise(r=>canvas.toBlob(r,type,q));
const blobToArrayBuffer = (b)=>new Promise(r=>{const fr=new FileReader(); fr.onload=()=>r(fr.result); fr.readAsArrayBuffer(b);});

// ---- Shared helper: compress canvas to a target size (KB) with slight overshoot (~1.2x) ----
async function compressCanvasToTarget(canvas, targetKB, mimeType, maxIters = 15) {
    const target = Math.max(1, Number(targetKB) || 1);
    const type = mimeType || 'image/jpeg';
    // Binary search over quality
    let lo = 5, hi = 100;
    let best = { blob: null, kb: Infinity, q: 80 };
    async function blobForQ(q) {
        const b = await canvasToBlob(canvas, type, q/100);
        return { blob: b, kb: b.size/1024, q };
    }
    for (let i=0;i<maxIters;i++) {
        const mid = Math.round((lo + hi)/2);
        const cur = await blobForQ(mid);
        if (Math.abs(cur.kb - target) < Math.abs(best.kb - target)) best = cur;
        if (cur.kb > target) hi = mid - 1; else lo = mid + 1;
    }
    // Prefer a gentle overshoot (≈ 1.2×) so that "target 20 KB" ends ~24 KB.
    const overshootAim = target * 1.2;
    let candidate = best;
    if (best.kb < target) {
        // Try a tad higher quality near the found point to get closer to 1.2× target
        let tryQ = Math.min(100, Math.max(best.q + 3, 1));
        const bump = await blobForQ(tryQ);
        if (Math.abs(bump.kb - overshootAim) < Math.abs(candidate.kb - overshootAim)) candidate = bump;
        // Another small bump
        tryQ = Math.min(100, tryQ + 3);
        const bump2 = await blobForQ(tryQ);
        if (Math.abs(bump2.kb - overshootAim) < Math.abs(candidate.kb - overshootAim)) candidate = bump2;
    } else if (best.kb > overshootAim) {
        // If we overshot too much, try nudging down a bit
        let tryQ = Math.max(1, best.q - 3);
        const nudge = await blobForQ(tryQ);
        if (Math.abs(nudge.kb - overshootAim) < Math.abs(candidate.kb - overshootAim)) candidate = nudge;
    }
    return candidate;
}

const u32 = (n)=> [(n>>>24)&255,(n>>>16)&255,(n>>>8)&255,n&255];
const isPdf = (file) => file.type === 'application/pdf';

async function showDownloadAlert(file, blob, message) {
    const originalSizeKB = file.size / 1024;
    const newSizeKB = blob.size / 1024;
    const reduction = 100 - (newSizeKB / originalSizeKB * 100);
    const alertMessage = `Original size: ${originalSizeKB.toFixed(1)} KB\n` +
                         `New file size: ${newSizeKB.toFixed(1)} KB\n` +
                         `Size reduction: ${reduction.toFixed(1)}%`;
    alert(alertMessage);
}

function initiateDownload(blob, filename) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
}


/* ---------------- 1) JPG → PDF ---------------- */
document.getElementById('jpgPdfBtn').addEventListener('click', async ()=>{
  const input = document.getElementById('jpgPdfFiles');
  if(!input.files.length) return alert('Please select images');
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ unit: 'mm', format: 'a4' });
  for(let i=0;i<input.files.length;i++){
    const img = await fileToImage(input.files[i]);
    const pageW = pdf.internal.pageSize.getWidth();
    const pageH = pdf.internal.pageSize.getHeight();
    const ratio = Math.min(pageW / img.width, pageH / img.height);
    const w = img.width * ratio, h = img.height * ratio;
    const offX = (pageW - w)/2, offY = (pageH - h)/2;
    const can = document.createElement('canvas'); can.width = img.width; can.height = img.height;
    can.getContext('2d').drawImage(img,0,0);
    const dataUrl = can.toDataURL('image/jpeg', 0.95);
    if(i>0) pdf.addPage();
    pdf.addImage(dataUrl, 'JPEG', offX, offY, w, h);
  }
  pdf.save('images.pdf');
});

/* ---------------- 2) Image Resizer ---------------- */
document.getElementById('preset').addEventListener('change', ()=>{
  const v = document.getElementById('preset').value;
  if(!v) return;
  const [w,h] = v.split('x');
  document.getElementById('resizeW').value = w;
  document.getElementById('resizeH').value = h;
  document.getElementById('resizeUnit').value = 'px';
});


document.getElementById('resizeBtn').addEventListener('click', async ()=>{
  const file = document.getElementById('resizeFile').files[0];
  if(!file) return alert('Select image');
  let w = Number(document.getElementById('resizeW').value);
  let h = Number(document.getElementById('resizeH').value);
  const unit = document.getElementById('resizeUnit').value;
  const dpi = Number(document.getElementById('resizeDpi').value)||300;
  const img = await fileToImage(file);
  if(unit !== 'px'){
    const toPx = (v)=> unit==='cm' ? v * dpi / 2.54 : unit==='in' ? v * dpi : unit==='mm' ? v * dpi / 25.4 : v;
    w = Math.round(toPx(w));
    h = Math.round(toPx(h));
  }
  if(!w || !h) return alert('Width and height required');
  const canvas = document.getElementById('resizeCanvas'); canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
  ctx.drawImage(img, 0, 0, w, h);

  // keep original type (jpeg->jpeg, png->png)
  const isJpg = /jpe?g/i.test(file.type) || /\.jpe?g$/i.test(file.name);
  const mime  = isJpg ? 'image/jpeg' : 'image/png';
  const ext   = isJpg ? 'jpg' : 'png';
  const q     = isJpg ? 0.9 : 0.95;

  const blob = await canvasToBlob(canvas, mime, q);
  initiateDownload(blob, `resized_${w}x${h}.${ext}`);
  document.getElementById('resizeResult').textContent = `Resized to ${w}×${h}px → ${ext.toUpperCase()}`;
});
        /* ---------------- 3) DPI Changer (accurate) ---------------- */
function setJfifDensity(u8, dpi){
  let i = 2;
  while(i < u8.length - 10){
    if(u8[i] !== 0xFF){ i++; continue; }
    const marker = u8[i+1];
    if(marker === 0xDA) break;
    const len = (u8[i+2]<<8) | u8[i+3];
    if(marker === 0xE0 && u8[i+4]===0x4A && u8[i+5]===0x46 && u8[i+6]===0x49 && u8[i+7]===0x46 && u8[i+8]===0x00){
      const posUnits = i + 11;
      u8[posUnits] = 1;
      const x = Math.min(65535, dpi);
      u8[posUnits+1] = (x>>8)&255; u8[posUnits+2]=x&255;
      u8[posUnits+3] = (x>>8)&255; u8[posUnits+4]=x&255;
      return u8;
    }
    i += 2 + len;
  }
  const app0 = new Uint8Array([
    0xFF,0xE0, 0x00,0x10,
    0x4A,0x46,0x49,0x46,0x00,
    0x01,0x02,
    0x01,
    (dpi>>8)&255, dpi&255,
    (dpi>>8)&255, dpi&255,
    0x00,0x00
  ]);
  const out = new Uint8Array(u8.length + app0.length);
  out.set(u8.subarray(0,2),0);
  out.set(app0,2);
  out.set(u8.subarray(2),2+app0.length);
  return out;
}

function setPngPhys(u8, dpi){
  const ppm = Math.max(1, Math.round(dpi * 39.37007874));
  const sig = [137,80,78,71,13,10,26,10];
  for(let k=0;k<8;k++) if(u8[k]!==sig[k]) return u8;
  let pos = 8;
  let found = false;
  while(pos < u8.length){
    const len = (u8[pos]<<24)|(u8[pos+1]<<16)|(u8[pos+2]<<8)|u8[pos+3];
    const type = String.fromCharCode(u8[pos+4],u8[pos+5],u8[pos+6],u8[pos+7]);
    if(type === 'pHYs'){
      const bytes = u8;
      bytes[pos+8] = (ppm>>24)&255; bytes[pos+9]=(ppm>>16)&255; bytes[pos+10]=(ppm>>8)&255; bytes[pos+11]=ppm&255;
      bytes[pos+12] = (ppm>>24)&255; bytes[pos+13]=(ppm>>16)&255; bytes[pos+14]=(ppm>>8)&255; bytes[pos+15]=ppm&255;
      bytes[pos+16] = 1;
      found = true; break;
    }
    if(type==='IDAT' || type==='IEND') break;
    pos += 12 + len;
  }
  if(found) return u8;
  const ihdrLen = (u8[8]<<24)|(u8[9]<<16)|(u8[10]<<8)|u8[11];
  const ihdrEnd = 8 + 12 + ihdrLen;
  function crc32(buf){
    let c = ~0 >>> 0;
    for(let i=0;i<buf.length;i++){
      c = (c >>> 8) ^ CRC_TABLE[(c ^ buf[i]) & 0xff];
    }
    return (~c) >>> 0;
  }
  const CRC_TABLE = (()=>{ let t=[]; for(let n=0;n<256;n++){ let c=n; for(let k=0;k<8;k++) c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1); t[n]=c>>>0;} return t; })();
  const lenBytes = new Uint8Array(u32(9));
  const typeBytes = new TextEncoder().encode('pHYs');
  const data = new Uint8Array(9);
  const ppmBuf = u32(ppm);
  data.set(ppmBuf,0); data.set(ppmBuf,4); data[8]=1;
  const crcBuf = new Uint8Array(typeBytes.length + data.length);
  crcBuf.set(typeBytes,0); crcBuf.set(data,typeBytes.length);
  const crc = crc32(crcBuf);
  const crcBytes = new Uint8Array(u32(crc));
  const physChunk = new Uint8Array(lenBytes.length + typeBytes.length + data.length + crcBytes.length);
  physChunk.set(lenBytes,0); physChunk.set(typeBytes,4); physChunk.set(data,8); physChunk.set(crcBytes,17);
  const out = new Uint8Array(u8.length + physChunk.length);
  out.set(u8.subarray(0, ihdrEnd), 0);
  out.set(physChunk, ihdrEnd);
  out.set(u8.subarray(ihdrEnd), ihdrEnd + physChunk.length);
  return out;
}

document.getElementById('dpiBtn').addEventListener('click', async ()=>{
  const file = document.getElementById('dpiFile').files[0];
  if(!file) return alert('Select JPEG or PNG');
  const dpi = Math.max(1, Math.min(1200, Number(document.getElementById('dpiValue').value)||300));
  const mode = document.getElementById('dpiMode').value;
  const img = await fileToImage(file);
  const canvas = document.getElementById('dpiCanvas');
  if(mode === 'keep'){
    canvas.width = img.width; canvas.height = img.height;
  } else {
    const oldDPI = 72;
    canvas.width = Math.max(1, Math.round(img.width * dpi / oldDPI));
    canvas.height = Math.max(1, Math.round(img.height * dpi / oldDPI));
  }
  const ctx = canvas.getContext('2d'); ctx.imageSmoothingQuality = 'high'; ctx.drawImage(img,0,0,canvas.width,canvas.height);
  const wantPNG = (/\.png$/i).test(file.name);
  const blob = await canvasToBlob(canvas, wantPNG ? 'image/png' : 'image/jpeg', 0.95);
  let u8 = new Uint8Array(await blobToArrayBuffer(blob));
  if(wantPNG){
    u8 = setPngPhys(u8, dpi);
    const outBlob = new Blob([u8], { type: 'image/png' });
    
    showDownloadAlert(file, outBlob);
    initiateDownload(outBlob, `dpi_${dpi}.png`);
    document.getElementById('dpiInfo').textContent = `Wrote ${dpi} DPI into PNG pHYs.`;
  } else {
    u8 = setJfifDensity(u8, dpi);
    try{
      const b64 = 'data:image/jpeg;base64,' + btoa(String.fromCharCode(...u8));
      let ex = {};
      try { ex = piexif.load(b64); } catch(e){ ex = {"0th":{}, "Exif":{}, "GPS":{}, "1st":{}, "thumbnail": null}; }
      ex["0th"][piexif.ImageIFD.XResolution] = [dpi,1];
      ex["0th"][piexif.ImageIFD.YResolution] = [dpi,1];
      ex["0th"][piexif.ImageIFD.ResolutionUnit] = 2;
      const exStr = piexif.dump(ex);
      const inserted = piexif.insert(exStr, b64);
      const bin = atob(inserted.split(',')[1]);
      const arr = new Uint8Array(bin.length);
      for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
      const outBlob = new Blob([arr], { type: 'image/jpeg' });
      
      showDownloadAlert(file, outBlob);
      initiateDownload(outBlob, `dpi_${dpi}.jpg`);
      document.getElementById('dpiInfo').textContent = `Wrote ${dpi} DPI into JPEG JFIF + EXIF.`;
    }catch(e){
      const outBlob = new Blob([u8], { type: 'image/jpeg' });
      showDownloadAlert(file, outBlob);
      initiateDownload(outBlob, `dpi_${dpi}.jpg`);
      document.getElementById('dpiInfo').textContent = `Wrote ${dpi} DPI into JPEG JFIF.`;
    }
  }
});

/* ---------------- 4) Image Compressor ---------------- */
// === Smart compressor: prefers WebP for documents, binary-search quality + gentle downscale ===
async function compressCanvasToTargetSmart(srcCanvas, targetKB, prefer = 'image/webp', maxAttempts = 10, onProgress) {
  const targetBytes = Math.max(1, Math.round(targetKB * 1024));
  const mimeOrder = [prefer, 'image/jpeg'];
  const toBlob = (canvas, type, q) => new Promise(res => canvas.toBlob(b => res(b), type, q));

  let work = document.createElement('canvas');
  let w = work.width = srcCanvas.width;
  let h = work.height = srcCanvas.height;
  let ctx = work.getContext('2d', { alpha: true });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(srcCanvas, 0, 0, w, h);

  const progress = (p)=>{ if (typeof onProgress === 'function') onProgress(Math.max(0, Math.min(99, Math.round(p)))); };

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const baseProg = (attempt/maxAttempts)*80; // keep final 20% for finishing
    for (let m = 0; m < mimeOrder.length; m++) {
      const mime = mimeOrder[m];
      let qMin = 0.35, qMax = 0.92, bestBlob = null, bestBytes = Infinity, bestQ = 0.82;
      for (let i = 0; i < 7; i++) {
        const q = (qMin + qMax) / 2;
        const blob = await toBlob(work, mime, q);
        const bytes = blob ? blob.size : Infinity;
        const stepProg = baseProg + (m/mimeOrder.length)*10 + ((i+1)/7)*10;
        progress(stepProg);

        if (bytes <= targetBytes) {
          bestBlob = blob; bestBytes = bytes; bestQ = q;
          qMin = q; // try higher quality under cap
        } else {
          qMax = q;
        }
      }
      if (bestBlob && bestBytes <= targetBytes) {
        progress(98);
        return { blob: bestBlob, kb: bestBytes/1024, mime, q: bestQ, width: w, height: h };
      }
    }
    // gentle downscale if quality search failed
    const scale = 0.9; // small step to preserve readability
    const newW = Math.max(64, Math.round(w * scale));
    const newH = Math.max(64, Math.round(h * scale));
    if (newW === w && newH === h) break;
    const next = document.createElement('canvas');
    next.width = newW; next.height = newH;
    const nctx = next.getContext('2d', { alpha: true });
    nctx.imageSmoothingEnabled = true;
    nctx.imageSmoothingQuality = 'high';
    nctx.drawImage(work, 0, 0, w, h, 0, 0, newW, newH);
    work = next; ctx = nctx; w = newW; h = newH;
  }
  const fallback = await toBlob(work, 'image/jpeg', 0.7);
  progress(98);
  return { blob: fallback, kb: (fallback?.size||0)/1024, mime: 'image/jpeg', q: 0.7, width: w, height: h };
}

const cmpQ = document.getElementById('cmpQuality');
const cmpQLabel = document.getElementById('cmpQLabel');
cmpQ.addEventListener('input', ()=>cmpQLabel.textContent = cmpQ.value);




document.getElementById('cmpBtn').addEventListener('click', async ()=>{
  const file = document.getElementById('cmpFile').files[0];
  if(!file) return alert('Select image');

  const canvas = document.getElementById('cmpCanvas');
  const ctx = canvas.getContext('2d');
  const img = await fileToImage(file);
  canvas.width = img.width; canvas.height = img.height;
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(img, 0, 0);

  const outFmtSel = document.getElementById('cmpFormat').value;
  const targetKB = Number(document.getElementById('cmpTargetKB').value) || 0;
  const initQ = Math.max(1, Math.min(100, Number(document.getElementById('cmpQuality').value)||80));
  const type = (outFmtSel==='auto') ? (file.type || 'image/jpeg') : outFmtSel;
  const docMode = document.getElementById('cmpDocMode')?.checked;

  // Progress UI
  const barWrap = document.getElementById('cmpProgBarWrap');
  const bar = document.getElementById('cmpProgBar');
  const txt = document.getElementById('cmpProgText');
  const info = document.getElementById('cmpInfo');
  barWrap.classList.remove('hidden'); txt.classList.remove('hidden');
  bar.style.width = '0%'; txt.textContent = '0%'; info.textContent = 'Processing…';

  function setProg(p){ const v = Math.max(0, Math.min(99, Math.round(p))); bar.style.width = v+'%'; txt.textContent = v+'%'; }

  let resultBlob, resultKB, ext;

  if (docMode) {
    // Document pipeline
    const work = document.createElement('canvas');
    work.width = canvas.width; work.height = canvas.height;
    const wctx = work.getContext('2d', { willReadFrequently: true });
    wctx.drawImage(canvas, 0, 0);

    grayscaleInPlace(work);
    autoContrastInPlace(work, 0.5);
    const thr = otsuThreshold(work);
    thresholdInPlace(work, thr);
    unsharpMask(work, 0.6);

    if (targetKB > 0) {
      const prefer = (outFmtSel==='auto') ? 'image/webp' : outFmtSel;
      const r = await compressToTargetDoc(work, targetKB, prefer, setProg);
      resultBlob = r.blob; resultKB = r.kb; ext = r.ext;
    } else {
      resultBlob = await canvasToBlob(work, 'image/webp', 0.85);
      resultKB = (resultBlob?.size||0)/1024; ext = 'webp';
    }
  } else {
    // Photo/normal pipeline
    if (targetKB > 0) {
      const prefer = (outFmtSel==='auto') ? 'image/webp' : type;
      const result = await compressCanvasToTargetSmart(canvas, targetKB, prefer, 10, setProg);
      resultBlob = result.blob; resultKB = result.kb; ext = result.mime === 'image/webp' ? 'webp' : 'jpg';
    } else {
      resultBlob = await canvasToBlob(canvas, type, initQ/100);
      resultKB = resultBlob.size/1024; ext = (type.split('/')[1] || 'jpg');
    }
  }

  bar.style.width = '100%'; txt.textContent = '100%';
  setTimeout(()=>{ barWrap.classList.add('hidden'); txt.classList.add('hidden'); }, 600);

  if (resultBlob) {
    showDownloadAlert(file, resultBlob);
    const base = (file.name.split('.').slice(0,-1).join('.')) || 'image';
    initiateDownload(resultBlob, `compressed_${base}.${ext}`);
    info.textContent = `File compressed to ${resultKB.toFixed(1)} KB (${ext.toUpperCase()}).`;
  } else {
    info.textContent = 'Could not compress file. Please try again.';
  }
});



/* ---------------- 5) Image Format Converter ---------------- */
document.getElementById('convertBtn').addEventListener('click', async ()=>{
  const file = document.getElementById('convertFile').files[0];
  if(!file) return alert('Please select an image file');
  const outputFormat = document.getElementById('convertFormat').value;
  const img = await fileToImage(file);
  const canvas = document.getElementById('convertCanvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, img.width, img.height);
  const blob = await canvasToBlob(canvas, outputFormat, 0.95);
  
  showDownloadAlert(file, blob);
  initiateDownload(blob, `converted.${outputFormat.split('/')[1]}`);
  document.getElementById('convertInfo').textContent = `Image converted to ${outputFormat.split('/')[1].toUpperCase()} and downloaded.`;
});

/* ---------------- 6) Basic Grammar Checker ---------------- */
document.getElementById('grammarBtn').addEventListener('click', ()=>{
    const input = document.getElementById('grammarInput').value;
    const outputDiv = document.getElementById('grammarOutput');
    let outputHTML = input;
    const corrections = {
        'i am': 'I am',
        "i'm": "I'm",
        'i ': 'I ',
        '. ': '. ',
        '..': '.',
        'i,': 'I,',
        'i.': 'I.',
    };
    for (const [wrong, correct] of Object.entries(corrections)) {
        const regex = new RegExp(`\\b${wrong.replace(/[\.\?]/g, '\\$&')}\\b`, 'gi');
        outputHTML = outputHTML.replace(regex, (match) => {
            if (match === correct) {
                return correct;
            }
            return `<span class="suggestion">${match}</span><span class="correction">(${correct})</span>`;
        });
    }
    if (outputHTML.length > 0) {
        outputHTML = outputHTML.charAt(0).toUpperCase() + outputHTML.slice(1);
    }
    if (outputHTML.length > 0 && !/[.!?]$/.test(outputHTML)) {
        outputHTML += '<span class="suggestion"></span><span class="correction">(.)</span>';
    }
    outputDiv.innerHTML = outputHTML;
});

/* ---------------- 7) Image Cropper ---------------- */
let cropper;

document.getElementById('cropperFile').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const img = document.getElementById('cropperImg');
    const container = document.getElementById('cropper-container');
    const actions = document.getElementById('cropperActions');
    const cropperInfo = document.getElementById('cropperInfo');

    const reader = new FileReader();
    reader.onload = function(event) {
        img.src = event.target.result;
        container.classList.remove('hidden');
        actions.classList.remove('hidden');
        cropperInfo.textContent = 'Use your mouse to select an area to crop.';
        if (cropper) {
            cropper.destroy();
        }
        cropper = new Cropper(img, {
            viewMode: 1,
            aspectRatio: NaN,
            autoCropArea: 1,
            responsive: true,
        });
    };
    reader.readAsDataURL(file);
});

document.getElementById('cropperBtn').addEventListener('click', async () => {
    if (!cropper) return alert('Please select an image first.');
    const croppedCanvas = cropper.getCroppedCanvas();
    const blob = await new Promise(resolve => croppedCanvas.toBlob(resolve, 'image/png'));
    
    const file = document.getElementById('cropperFile').files[0];
    showDownloadAlert(file, blob);
    initiateDownload(blob, 'cropped_image.png');

    document.getElementById('cropperInfo').textContent = 'Image cropped and downloaded successfully.';
});

/* ---------------- 8) Image Filter/Effects ---------------- */
let originalImg = null;
const filterCanvas = document.getElementById('filterCanvas');
const filterCtx = filterCanvas.getContext('2d');
let currentFilter = 'none';
let brightness = 100;
let contrast = 100;

document.getElementById('filterFile').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const previewContainer = document.getElementById('filter-preview-container');
    const controls = document.getElementById('filterControls');
    const filterInfo = document.getElementById('filterInfo');

    originalImg = await fileToImage(file);
    filterCanvas.width = originalImg.width;
    filterCanvas.height = originalImg.height;
    filterCtx.drawImage(originalImg, 0, 0);

    previewContainer.classList.remove('hidden');
    controls.classList.remove('hidden');
    filterInfo.textContent = 'Image loaded. Apply filters and effects.';
    
    currentFilter = 'none';
    brightness = 100;
    contrast = 100;
    document.getElementById('brightness').value = 100;
    document.getElementById('contrast').value = 100;
    applyFilter();
});

function applyFilter() {
    if (!originalImg) return;
    filterCtx.clearRect(0, 0, filterCanvas.width, filterCanvas.height);
    let filterString = `brightness(${brightness}%) contrast(${contrast}%)`;
    if (currentFilter !== 'none') {
        filterString = `${currentFilter}(1) ` + filterString;
    }
    filterCtx.filter = filterString;
    filterCtx.drawImage(originalImg, 0, 0, originalImg.width, originalImg.height);
}

document.querySelectorAll('.filter-btn').forEach(button => {
    button.addEventListener('click', () => {
        currentFilter = button.dataset.filter;
        applyFilter();
    });
});

document.getElementById('brightness').addEventListener('input', (e) => {
    brightness = e.target.value;
    applyFilter();
});

document.getElementById('contrast').addEventListener('input', (e) => {
    contrast = e.target.value;
    applyFilter();
});

document.getElementById('resetFilterBtn').addEventListener('click', () => {
    currentFilter = 'none';
    brightness = 100;
    contrast = 100;
    document.getElementById('brightness').value = 100;
    document.getElementById('contrast').value = 100;
    applyFilter();
});

document.getElementById('downloadFilterBtn').addEventListener('click', async () => {
    if (!originalImg) return alert('Please select an image first.');
    const blob = await canvasToBlob(filterCanvas, 'image/png');
    
    const file = document.getElementById('filterFile').files[0];
    showDownloadAlert(file, blob);
    initiateDownload(blob, `filtered_image.png`);
    
    document.getElementById('filterInfo').textContent = 'Filtered image downloaded successfully.';
});



function grayscaleInPlace(canvas){
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const d = ctx.getImageData(0,0,canvas.width,canvas.height);
  const a = d.data;
  for(let i=0;i<a.length;i+=4){
    const y = (a[i]*0.2126 + a[i+1]*0.7152 + a[i+2]*0.0722)|0;
    a[i]=a[i+1]=a[i+2]=y;
  }
  ctx.putImageData(d,0,0);
}

function autoContrastInPlace(canvas, clipPct=0.5){
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const d = ctx.getImageData(0,0,canvas.width,canvas.height);
  const a = d.data;

  const hist = new Array(256).fill(0);
  for(let i=0;i<a.length;i+=4) hist[a[i]]++;

  const total = canvas.width*canvas.height;
  const clip = Math.floor(total*clipPct/100);
  let low=0, run=0; while(low<256 && (run+=hist[low])<=clip) low++;
  let high=255; run=0; while(high>=0 && (run+=hist[high])<=clip) high--;

  const span = Math.max(1, high-low);
  for(let i=0;i<a.length;i+=4){
    const y = a[i];
    const v = Math.max(0, Math.min(255, ((y-low)*255/span)|0));
    a[i]=a[i+1]=a[i+2]=v;
  }
  ctx.putImageData(d,0,0);
}

function otsuThreshold(canvas){
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const d = ctx.getImageData(0,0,canvas.width,canvas.height);
  const a = d.data;
  const hist = new Array(256).fill(0);
  for(let i=0;i<a.length;i+=4) hist[a[i]]++;
  const total = canvas.width*canvas.height;

  let sum=0; for(let t=0;t<256;t++) sum += t*hist[t];
  let sumB=0, wB=0, wF=0, varMax=0, thresh=127;

  for(let t=0;t<256;t++){
    wB += hist[t];
    if (wB===0) continue;
    wF = total - wB; if (wF===0) break;
    sumB += t*hist[t];
    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;
    const varBetween = wB*wF*(mB-mF)*(mB-mF);
    if (varBetween > varMax){ varMax = varBetween; thresh = t; }
  }
  return thresh;
}

function thresholdInPlace(canvas, thr){
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const d = ctx.getImageData(0,0,canvas.width,canvas.height);
  const a = d.data;
  for(let i=0;i<a.length;i+=4){
    const y = a[i] < thr ? 0 : 255;
    a[i]=a[i+1]=a[i+2]=y;
  }
  ctx.putImageData(d,0,0);
}

function unsharpMask(canvas, amount=0.6){
  // Simple 3x3 sharpen
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const w = canvas.width, h = canvas.height;
  const src = ctx.getImageData(0,0,w,h);
  const dst = ctx.createImageData(w,h);
  const s = src.data, d = dst.data;
  const k = [0,-1,0,-1,5, -1,0,-1,0];
  const ix = (x,y)=> (y*w + x)<<2;
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let r=0,g=0,b=0, idx=0;
      for(let ky=-1;ky<=1;ky++){
        for(let kx=-1;kx<=1;kx++){
          const p = ix(x+kx,y+ky);
          const wgt = k[idx++];
          r += s[p]*wgt; g += s[p+1]*wgt; b += s[p+2]*wgt;
        }
      }
      const q = ix(x,y);
      d[q]   = Math.max(0,Math.min(255, r*amount + s[q]*(1-amount)));
      d[q+1] = Math.max(0,Math.min(255, g*amount + s[q+1]*(1-amount)));
      d[q+2] = Math.max(0,Math.min(255, b*amount + s[q+2]*(1-amount)));
      d[q+3] = s[q+3];
    }
  }
  ctx.putImageData(dst,0,0);
}

async function compressToTargetDoc(workCanvas, targetKB, preferMime='image/webp', onProgress){
  const targetBytes = Math.max(1, Math.round(targetKB*1024));
  const toBlob = (c, type, q)=> new Promise(res=> c.toBlob(b=>res(b), type, q));
  const mimeOrder = [preferMime, 'image/png'];

  for (let m=0; m<mimeOrder.length; m++){
    const mime = mimeOrder[m];
    if (mime === 'image/png'){
      let w = workCanvas.width, h = workCanvas.height;
      for (let attempts=0; attempts<5; attempts++){
        const blob = await toBlob(workCanvas, 'image/png');
        if (blob && blob.size <= targetBytes) {
          return { blob, kb: blob.size/1024, ext: 'png' };
        }
        // downscale gently
        const next = document.createElement('canvas');
        next.width = Math.max(64, Math.round(w*0.9));
        next.height= Math.max(64, Math.round(h*0.9));
        next.getContext('2d').drawImage(workCanvas, 0,0,w,h, 0,0,next.width,next.height);
        workCanvas = next; w = next.width; h = next.height;
        onProgress?.(70 + (attempts+1)*5);
      }
    } else {
      // WebP binary search
      let qMin=0.45, qMax=0.95, best=null, bestBytes=Infinity;
      for (let i=0;i<7;i++){
        const q = (qMin+qMax)/2;
        const blob = await toBlob(workCanvas, 'image/webp', q);
        const bytes = blob ? blob.size : Infinity;
        onProgress?.(35 + ((i+1)/7)*35);
        if (bytes <= targetBytes){ best=blob; bestBytes=bytes; qMin=q; } else { qMax=q; }
      }
      if (best) return { blob: best, kb: bestBytes/1024, ext: 'webp' };
      // gentle downscale then quick retry
      const next = document.createElement('canvas');
      next.width = Math.max(64, Math.round(workCanvas.width*0.9));
      next.height= Math.max(64, Math.round(workCanvas.height*0.9));
      next.getContext('2d').drawImage(workCanvas, 0,0,workCanvas.width,workCanvas.height, 0,0,next.width,next.height);
      workCanvas = next;
      let b2=null, b2Bytes=Infinity;
      for (let i=0;i<5;i++){
        const q = 0.75 - i*0.08;
        const blob = await toBlob(workCanvas, 'image/webp', q);
        const bytes = blob ? blob.size : Infinity;
        onProgress?.(75 + ((i+1)/5)*20);
        if (bytes <= targetBytes && bytes < b2Bytes){ b2=blob; b2Bytes=bytes; }
      }
      if (b2) return { blob: b2, kb: b2Bytes/1024, ext: 'webp' };
    }
  }
  const fb = await new Promise(res=> workCanvas.toBlob(b=>res(b), 'image/jpeg', 0.6));
  return { blob: fb, kb: (fb?.size||0)/1024, ext: 'jpg' };
}


// === Document vs Photo compression helpers ===
function grayscaleInPlace(canvas){
  const ctx = canvas.getContext('2d',{willReadFrequently:true});
  const d = ctx.getImageData(0,0,canvas.width,canvas.height), a=d.data;
  for(let i=0;i<a.length;i+=4){
    const y = (a[i]*0.2126 + a[i+1]*0.7152 + a[i+2]*0.0722)|0;
    a[i]=a[i+1]=a[i+2]=y;
  }
  ctx.putImageData(d,0,0);
}
function autoContrastInPlace(canvas, clipPct=0.5){
  const ctx = canvas.getContext('2d',{willReadFrequently:true});
  const d = ctx.getImageData(0,0,canvas.width,canvas.height), a=d.data;
  const hist = new Array(256).fill(0); for(let i=0;i<a.length;i+=4) hist[a[i]]++;
  const total=canvas.width*canvas.height, clip=Math.floor(total*clipPct/100);
  let low=0,c=0; while(low<256 && (c+=hist[low])<=clip) low++;
  let high=255; c=0; while(high>=0 && (c+=hist[high])<=clip) high--;
  const span=Math.max(1,high-low);
  for(let i=0;i<a.length;i+=4){ const y=a[i]; const v=Math.max(0,Math.min(255,((y-low)*255/span)|0)); a[i]=a[i+1]=a[i+2]=v; }
  ctx.putImageData(d,0,0);
}
function otsuThreshold(canvas){
  const ctx = canvas.getContext('2d',{willReadFrequently:true});
  const d=ctx.getImageData(0,0,canvas.width,canvas.height), a=d.data, hist=new Array(256).fill(0);
  for(let i=0;i<a.length;i+=4) hist[a[i]]++;
  const total=canvas.width*canvas.height; let sum=0; for(let t=0;t<256;t++) sum+=t*hist[t];
  let sumB=0, wB=0, varMax=0, thr=127;
  for(let t=0;t<256;t++){ wB+=hist[t]; if(!wB)continue; const wF=total-wB; if(!wF)break; sumB+=t*hist[t];
    const mB=sumB/wB, mF=(sum-sumB)/wF, vb=wB*wF*(mB-mF)*(mB-mF); if(vb>varMax){varMax=vb;thr=t;} }
  return thr;
}
function thresholdInPlace(canvas, thr){
  const ctx = canvas.getContext('2d',{willReadFrequently:true});
  const d = ctx.getImageData(0,0,canvas.width,canvas.height), a=d.data;
  for(let i=0;i<a.length;i+=4){ const y=a[i]<thr?0:255; a[i]=a[i+1]=a[i+2]=y; }
  ctx.putImageData(d,0,0);
}
function unsharpMask(canvas, amt=0.5){
  const ctx=canvas.getContext('2d',{willReadFrequently:true}), w=canvas.width,h=canvas.height;
  const src=ctx.getImageData(0,0,w,h), dst=ctx.createImageData(w,h), s=src.data, d=dst.data;
  const k=[0,-1,0,-1,5,-1,0,-1,0], idx=(x,y)=>((y*w+x)<<2);
  for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){ let r=0,g=0,b=0,i=0;
    for(let ky=-1;ky<=1;ky++)for(let kx=-1;kx<=1;kx++){ const p=idx(x+kx,y+ky), wgt=k[i++]; r+=s[p]*wgt; g+=s[p+1]*wgt; b+=s[p+2]*wgt; }
    const q=idx(x,y); d[q]=Math.max(0,Math.min(255, s[q]*(1-amt)+r*amt));
    d[q+1]=Math.max(0,Math.min(255, s[q+1]*(1-amt)+g*amt));
    d[q+2]=Math.max(0,Math.min(255, s[q+2]*(1-amt)+b*amt));
    d[q+3]=s[q+3];
  } }
  ctx.putImageData(dst,0,0);
}
function autoDetectDocument(canvas){
  const ctx=canvas.getContext('2d',{willReadFrequently:true});
  const d=ctx.getImageData(0,0,Math.min(128,canvas.width),Math.min(128,canvas.height)).data;
  let csum=0, n=0;
  for(let i=0;i<d.length;i+=16){ const r=d[i],g=d[i+1],b=d[i+2]; csum+=Math.max(r,g,b)-Math.min(r,g,b); n++; }
  return (csum/n) < 18;
}

})();</script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./service-worker.js')
    .catch(console.warn);
}</script><footer>
  <a href="seo.html" class="hidden-seo">SEO Overview</a> |
  <a href="sitemap.xml" class="hidden-seo">Sitemap</a> |
  <a href="robots.txt" class="hidden-seo">Robots.txt</a>
</footer>

<style>
.hidden-seo {
  position: absolute;
  left: -9999px; /* moves it off-screen */
}
</style>
</body>
</html>